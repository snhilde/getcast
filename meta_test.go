package main

import (
	"testing"
	"os/exec"
	"strings"
	"os"
	"bytes"
	"io/ioutil"
	"net/http"
	"io"
	"errors"
)


// refData is used to hold the information about a test file on disk, including its location, metadata size, and frames.
type refData struct {
	name       string
	path       string
	metasize   int // (header length + frames length)
	frames   []refFrame
}

// refFrame holds information about an individual frame in the metadata.
type refFrame struct {
	id    string // standard frame ID
	name  string // human-readable frame name
	value string // frame value
}


// We're going to use these generated audio files to test our ability to read metadata.
var localFiles = []refData {
	{ "White", "./audio/white.mp3", 10 + 291, []refFrame{
		{ "TIT2", "title",          "White Title"                       },
		{ "TPE1", "artist",         "White Artist"                      },
		{ "TALB", "album",          "White Album"                       },
		{ "TRCK", "track",          "1"                                 },
		{ "TDRC", "date",           "1111"                              }, // ID3v2.4 only
		{ "TCON", "genre",          "White Noise"                       },
		{ "COMM", "comment",        "White noise generated by Audacity" },
		{ "TXXX", "Additional Tag", "Additional white noise tag"        },
	} },
	{ "Pink", "./audio/pink.mp3", 10 + 209, []refFrame{
		{ "TIT2", "title",          "Pink Title"                        },
		{ "TPE1", "artist",         "Pink Artist"                       },
		{ "TALB", "album",          "Pink Album"                        },
		{ "TRCK", "track",          "2"                                 },
		{ "TDRC", "date",           "22222"                             }, // ID3v2.4 only
		{ "TCON", "genre",          "Country"                           },
		{ "COMM", "comment",        "Pink noise"                        },
		{ "TYER", "TYER",           "22222"                             },
		{ "TXXX", "Pink",           "Noise"                             },
	} },
	{ "Brown", "./audio/brown.mp3", 10 + 117, []refFrame{
		{ "TIT2", "title",          "Brown Title"                       },
		{ "TPE1", "artist",         "Brown Artist"                      },
		{ "TALB", "album",          "Brown Album"                       },
		{ "TRCK", "track",          "3"                                 },
		{ "TDRC", "date",           "33"                                }, // ID3v2.4 only
		{ "TYER", "TYER",           "33"                                },
	} },
}

// We're going to use these podcast episodes to test our ability to download an episode and read and write the correct
// metadata. We're going to use podcasts in which we have reasonable confidence that the files will remain online for a
// long time and the metadata will not change.
var onlineFiles = []refData {
	{ "Joe Rogan", "http://traffic.libsyn.com/joeroganexp/p1000.mp3", 10 + 383990, []refFrame {
		{ "TIT2", "title",          "#1000 - Joey Diaz & Tom Segura" },
		{ "TPE1", "artist",         "Joe Rogan"                      },
		{ "TPE2", "artist",         "Joe Rogan"                      },
		{ "TALB", "album",          "The Joe Rogan Experience"       },
		{ "TCON", "genre",          "Podcast"                        },
	} },
}


// Test the ability to read metadata correctly. The mp3 files to read are local files.
func TestReadMetaLocal(t *testing.T) {
	// First, let's make sure that ffprobe is finding the correct metadata in our test files. If that looks good, then
	// we can see how our solution is looking.
	for _, file := range localFiles {
		checkRefMeta(t, file.name, file.path, file.frames)
	}

	// Now, let's see how our reader stacks up.
	for _, file := range localFiles {
		meta, _, err := readAudioFile(file.path)
		if err != nil {
			t.Error(file.name, "-", err)
			return
		}

		if num := checkRefFile(t, meta, file.frames); num > 0 {
			t.Error(file.name, "-", num, "errors")
		}
	}
}

// Test the ability to write metadata and files correctly. The files to copy and write are the same files in
// TestReadMetaLocal.
func TestWriteMetaLocal(t *testing.T) {
	// Read the reference files into memory, copy them, and write them back out. If they're equal, then the write
	// operation is good.
	for _, file := range localFiles {
		filepath := file.path
		meta, audio, err := readAudioFile(file.path)
		if err != nil {
			t.Error(file.name, "-", err)
			continue
		}

		// If we read the correct amount of metadata out, then the first byte in the audio data should be 0xFF.
		if audio[0] != 0xFF {
			t.Error(file.name, "- Audio data does not start with 0xFF")
		}

		// Check that we copied the correct amount of metadata.
		if meta.Len() != file.metasize {
			t.Error(file.name, "- Metadata sizes do not match")
			t.Log("\tExpected:", file.metasize)
			t.Log("\tReceived:", meta.Len())
		}

		// Now let's write the file to disk.
		filepath += "_tmp"
		if !writeData(t, file.name, filepath, meta.Bytes(), audio) {
			continue
		}

		// Let's use ffprobe to see if all of the metadata was written correctly.
		checkRefMeta(t, file.name, filepath, file.frames)

		// And then do one more check with our reader.
		meta, _, err = readAudioFile(file.path)
		if err != nil {
			t.Error(file.name, "-", err)
			return
		}
		if num := checkRefFile(t, meta, file.frames); num > 0 {
			t.Error(file.name, "-", num, "errors")
		}

		// Now that we're done, we can remove the temporary file.
		if err := os.Remove(filepath); err != nil {
			t.Error(file.name, "-", err)
		}
	}
}

// Test the ability to download and save a podcast episode with the correct file information and metadata.
func TestDownload(t *testing.T) {
	for _, file := range onlineFiles {
		resp, err := http.Get(file.path)
		if err != nil {
			t.Error(file.name, "-", err)
			continue
		}

		if resp.StatusCode != 200 {
			t.Error(file.name, "-", resp.Status)
			continue
		}

		meta := NewMeta(nil)

		// Download only the metadata.
		n, err := io.Copy(meta, resp.Body)
		resp.Body.Close()

		// If we read the correct amount of metadata out, then the first byte in the audio data should be 0xFF.
		b := make([]byte, 1)
		resp.Body.Read(b)
		if b[0] != 0xFF {
			t.Error(file.name, "- Audio data does not start with 0xFF")
		}

		if err != io.ErrShortWrite {
			t.Error(file.name, "-", err)
			continue
		} else if int(n) != file.metasize {
			t.Error(file.name, "- Metadata sizes do not match")
			t.Log("\tExpected:", file.metasize)
			t.Log("\tReceived:", meta.Len())
			// continue
		}

		if num := checkRefFile(t, meta, file.frames); num > 0 {
			t.Error(file.name, "-", num, "errors")
		}
	}
}


// checkRefMeta compares the metadata of a reference file using ffprobe to the expected metadata in the file table.
func checkRefMeta(t *testing.T, name string, filepath string, frames []refFrame) {
	// Get the frames from ffprobe's output.
	probeMeta, err := runProbe(filepath)
	if err != nil {
		t.Error(name, "-", err)
		return
	}

	for _, frame := range frames {
		want := frame.value
		have := probeMeta[frame.name]
		if want != have {
			t.Error(name, "- Values do not match for id:", frame.name, "/", frame.id)
			t.Log("\tExpected:", want)
			t.Log("\tFound:", have)
		}
		delete(probeMeta, frame.name)
	}

	// Make sure we found everything that we expected to find.
	if len(probeMeta) != 0 {
		t.Error(len(probeMeta), "keys remain in metadata for", name)
		t.Log("Keys remaining:", probeMeta)
	}
}

// checkRefFile compares the metadata of a reference file using our meta reader to the expected metadata in the file table.
func checkRefFile(t *testing.T, meta *Meta, frames []refFrame) int {
	numErrors := 0

	// Go through all of the known frames and make sure our meta reader found the same values.
	for _, frame := range frames {
		found := false

		// Look for a match in all of the values for this frame ID in the metadata.
		values := meta.GetValues(frame.id)
		if len(values) == 0 {
			t.Error("No values for frame id " + frame.id + " (" + frame.name + ")")
			numErrors++
			continue
		}

		for _, value := range values {
			switch frame.id {
			case "COMM":
				// If this frame is present, then there are usually 2 instances of it: one that starts with 3 null
				// bytes, and one that starts with three 'X' bytes. Either way, the next byte is a null separator
				// followed by the value.
				value = bytes.TrimLeft(value, string([]byte{0x00, 'X'}))
				if strings.TrimSpace(string(value)) == frame.value {
					found = true
				}
			case "TXXX":
				// This is the user-defined field. The frame name and frame value are separated by a null byte.
				fields := bytes.SplitN(value, []byte{0x00}, 2)
				if len(fields) == 2 && string(fields[0]) == frame.name && string(fields[1]) == frame.value {
					found = true
				}
			default:
				if strings.TrimSpace(string(value)) == frame.value {
					found = true
				}
			}

			if found {
				break
			}
		}

		if !found {
			numErrors++
			t.Error(errors.New("Value not found for frame id " + frame.id + " (" + frame.name + ")"))
		}
	}

	return numErrors
}


// runProbe runs ffprobe on the specified file and returns the metadata read as key/value pairs. Note that ffprobe does
// not return the actual tag name; it returns a human-readable format. For example, it returns "title" instead of "TIT2".
func runProbe(path string) (map[string]string, error) {
	cmd := exec.Command("ffprobe", "-hide_banner", path)
	output, err := cmd.CombinedOutput()
	if err != nil {
		return nil, err
	}

	// To find our metadata, we're going to read everything between the header (Metadata:) and trailer (Duration:).
	start := false
	meta := make(map[string]string)

	lines := strings.Split(string(output), "\n")
	for _, v := range lines {
		if strings.Contains(v, "Metadata:") {
			start = true
		} else if strings.Contains(v, "Duration:") {
			break
		} else if start {
			fields := strings.SplitN(v, ":", 2)
			id := strings.TrimSpace(fields[0])
			value := strings.TrimSpace(fields[1])
			meta[id] = value
		}
	}

	return meta, nil
}

// readAudioFile reads the data from the audio file and splits it into metadata and audio data.
func readAudioFile(path string) (*Meta, []byte, error) {
	// Open the reference file.
	file, err := os.Open(path)
	if err != nil {
		return nil, nil, err
	}

	// Get all the data from the file.
	data, err := ioutil.ReadAll(file)
	if err != nil {
		return nil, nil, err
	}
	defer file.Close()

	// Copy the metadata and the rest of the file.
	meta := NewMeta(data)
	audio := data[meta.Len():]

	return meta, audio, nil
}

// writeData writes the metadata and audio data to the specified file.
func writeData(t *testing.T, name string, filepath string, meta, audio []byte) bool {
	file, err := os.Create(filepath)
	if err != nil {
		t.Error(name, "-", err)
		return false
	}
	defer file.Close()

	// Write the metadata first.
	if n, err := file.Write(meta); err != nil {
		t.Error(name, "-", err)
		return false
	} else if n != len(meta) {
		t.Error(name, "- Failed to write correct number of bytes")
		t.Log("\tExpected:", len(meta))
		t.Log("\tActual  :", n)
		return false
	}

	// Then right the audio data.
	if n, err := file.Write(audio); err != nil {
		t.Error(name, "-", err)
		return false
	} else if n != len(audio) {
		t.Error(name, "- Failed to write correct number of bytes")
		t.Log("\tExpected:", len(audio))
		t.Log("\tActual  :", n)
		return false
	}

	return true
}
